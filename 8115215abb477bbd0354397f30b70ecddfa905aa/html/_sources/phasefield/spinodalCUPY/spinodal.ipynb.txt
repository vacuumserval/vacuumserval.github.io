{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Phase Field Model of Spinodal Decomposition\n",
    "\n",
    "Spinodal decomposition is a mechanism by which a single thermodynamic phase spontaneously separates into two phases (without nucleation). Decomposition occurs when there is no thermodynamic barrier to phase separation. As a result, phase separation via decomposition does not require the nucleation events resulting from thermodynamic fluctuations, which normally trigger phase separation. The free energy functional is modelled as:\n",
    "$$\n",
    "\\begin{align}\n",
    "    F = \\int_V\\left[Ac^2(1-c)^2+\\frac{\\kappa}{2}\\left(\\nabla c\\right)^2 \\right]dV\n",
    "\\end{align}\n",
    "$$\n",
    "dynamics of the free energy functional is:\n",
    "$$\n",
    "\\begin{align}\n",
    "\\frac{\\partial c}{\\partial t} &= M\\nabla^2\\left\\{2A\\left[c(1-c)^2 - c^2(1-c)\\right]-\\kappa\\nabla^2c\\right\\} \\nonumber \\\\\n",
    "&= M\\nabla^2\\left[2A\\left(2c^3-3c^2+c\\right)-\\kappa\\nabla^2c\\right] \\nonumber \\\\\n",
    "&\\Downarrow f_{nl}(c) = 4Ac^3-6Ac^2\\; \\cdots \\text{non-linear terms}\\nonumber \\\\\n",
    "&= M\\nabla^2\\left[f_{nl}(c) +2Ac-\\kappa\\nabla^2c\\right]\n",
    "\\end{align}\n",
    "$$\n",
    "The Fourier transform of it\n",
    "$$\n",
    "\\begin{align}\n",
    "\\frac{\\partial \\hat{c}}{\\partial t} &= -Mk^2\\left\\{\\hat{f}_{nl}(c)+(2A+\\kappa k^2)\\hat{c}\\right\\} \\nonumber \\\\\n",
    "&= -Mk^2\\hat{f}_{nl}(c) -Mk^2(2A+\\kappa k^2)\\hat{c}\n",
    "\\end{align}\n",
    "$$\n",
    "The iteration formule is\n",
    "$$\n",
    "\\begin{align}\n",
    "\\hat{c}^{t+1}-\\hat{c}^{t} &= -\\Delta t Mk^2\\hat{f}_{nl} - \\Delta t Mk^2(2A+\\kappa k^2)\\hat{c}^{t+1} \\\\\n",
    "\\left[1 + \\Delta t Mk^2(2A+\\kappa k^2)\\right] \\hat{c}^{t+1} &= \\hat{c}^{t}-\\Delta t Mk^2\\hat{f}_{nl}\n",
    "\\end{align}\n",
    "$$\n",
    "For a $M=1.0$, $\\kappa=0.5$, $A=1$ spinodal system"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from pyevtk.hl import gridToVTK\n",
    "import scipy.fft as sfft\n",
    "\n",
    "def ksComp(lx,ly,dx,dy):\n",
    "    \"\"\" Compute the k-space elements\n",
    "\n",
    "    Args:\n",
    "        lx (int): number of elements along x\n",
    "        ly (int): number of elements along y\n",
    "        dx (float): length step along x\n",
    "        dy (float): length step along y\n",
    "    \"\"\"\n",
    "    kxl = sfft.fftfreq(lx,d=dx/(2*np.pi)) # kx list\n",
    "    kyl = sfft.rfftfreq(ly,d=dy/(2*np.pi)) # ky list\n",
    "    [kxm, kym]=np.meshgrid(kxl, kyl,indexing='ij') # kx, ky matrices\n",
    "    k2m = kxm**2 + kym**2 # k^2 matrix\n",
    "    k4m = k2m**2 # k^4 matrix\n",
    "    return(kxm, kym, k2m, k4m)\n",
    "\n",
    "lx = 256        # length on x\n",
    "ly = 256        # length on y\n",
    "dx = dy = 1.0   # unit length\n",
    "c0 = 0.4        # initial composition average\n",
    "fluc = 0.05     # initial composition deviation\n",
    "A = 1.0         # factor A\n",
    "M = 1.0         # diffustion M\n",
    "dt = 0.05       # time step\n",
    "kappa = 0.5     # interface kappa\n",
    "tsteps = 5000   # simulation total steps\n",
    "dsteps = 250    # dump data every dsteps\n",
    "nsteps = 200    # nucleation steps (not used in this code)\n",
    "\n",
    "c = np.random.normal(c0, fluc, (lx, ly))    # initialize\n",
    "(kx, ky, k2, k4) = ksComp(lx, ly, dx, dy)   # prepare k's\n",
    "fname = 'spinodal'\n",
    "\n",
    "for t in range(tsteps):\n",
    "    fnl = 4*A*c**3 - 6*A*c**2   # f_nl\n",
    "    ck = sfft.rfft2(c)          # c(k)\n",
    "    fnlk = sfft.rfft2(fnl)      # f_nl(k)\n",
    "    nom = ck - dt*M*k2*fnlk              # nominator\n",
    "    denom = 1 + dt*M*k2*(2*A+kappa*k2)   # denominator\n",
    "    ck = nom/denom              # iteration\n",
    "    c = sfft.irfft2(ck)         # c\n",
    "    if (np.mod(t, dsteps) == 0):\n",
    "        c_3d = c[np.newaxis, :, :] \n",
    "        gridToVTK(fname+'.'+str(t), x=np.arange(ly)*dy, y=np.arange(lx)*dx, z=np.array([0.0]), pointData = {'composition': c_3d})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "for a 3-D case,"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from pyevtk.hl import gridToVTK\n",
    "import scipy.fft as sfft\n",
    "\n",
    "def ksComp(lx,ly,lz,dx,dy,dz):\n",
    "    \"\"\" Compute the k-space elements\n",
    "\n",
    "    Args:\n",
    "        lx (int): number of elements along x\n",
    "        ly (int): number of elements along y\n",
    "        lz (int): number of elements along z\n",
    "        dx (float): length step along x\n",
    "        dy (float): length step along y\n",
    "        dz (float): length step along z\n",
    "    \"\"\"\n",
    "    kxl = sfft.fftfreq(lx,d=dx/(2*np.pi)) # kx list\n",
    "    kyl = sfft.fftfreq(ly,d=dy/(2*np.pi)) # ky list\n",
    "    kzl = sfft.rfftfreq(lz,d=dz/(2*np.pi)) # kz list\n",
    "    [kxm, kym, kzm]=np.meshgrid(kxl, kyl, kzl, indexing='ij') # kx, ky, kz matrices\n",
    "    k2m = kxm**2 + kym**2 + kzm**2  # k^2 matrix\n",
    "    k4m = k2m**2   # k^4 matrix\n",
    "    return(kxm, kym, kzm, k2m, k4m)\n",
    "\n",
    "lx = 64         # length on x\n",
    "ly = 96         # length on y\n",
    "lz = 128        # length of z\n",
    "dx = dy = dz = 1.0   # unit length\n",
    "c0 = 0.4        # initial composition average\n",
    "fluc = 0.05     # initial composition deviation\n",
    "A = 1.0         # factor A\n",
    "M = 1.0         # diffustion M\n",
    "dt = 0.05       # time step\n",
    "kappa = 0.5     # interface kappa\n",
    "tsteps = 5000   # simulation total steps\n",
    "dsteps = 250    # dump data every dsteps\n",
    "nsteps = 200    # nucleation steps (not used in this code)\n",
    "\n",
    "c = np.random.normal(c0, fluc, (lx, ly, lz))    # initialize\n",
    "(kx, ky, kz, k2, k4) = ksComp(lx, ly, lz, dx, dy, dz)   # prepare k's\n",
    "fname = 'spinodal3D'\n",
    "\n",
    "for t in range(tsteps):\n",
    "    fnl = 4*A*c**3 - 6*A*c**2   # f_nl\n",
    "    ck = sfft.rfftn(c)          # c(k)\n",
    "    fnlk = sfft.rfftn(fnl)      # f_nl(k)\n",
    "    nom = ck - dt*M*k2*fnlk              # nominator\n",
    "    denom = 1 + dt*M*k2*(2*A+kappa*k2)   # denominator\n",
    "    ck = nom/denom              # iteration\n",
    "    c = sfft.irfftn(ck)         # c\n",
    "    if (np.mod(t, dsteps) == 0):\n",
    "        gridToVTK(fname+'.'+str(t), x=np.arange(lz)*dz, y=np.arange(ly)*dy, z=np.arange(lx)*dx, pointData = {'composition': c})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3D simulation is much slower, a GPU-accelerated library `cupy` can be adopted."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cupy as cp\n",
    "import numpy as np\n",
    "from pyevtk.hl import gridToVTK\n",
    "\n",
    "def ksComp(lx,ly,dx,dy):\n",
    "    \"\"\" Compute the k-space elements\n",
    "\n",
    "    Args:\n",
    "        lx (int): number of elements along x\n",
    "        ly (int): number of elements along y\n",
    "        dx (float): length step along x\n",
    "        dy (float): length step along y\n",
    "    \"\"\"\n",
    "    kxl = cp.fft.fftfreq(lx,d=dx/(2*cp.pi)) # kx list\n",
    "    kyl = cp.fft.rfftfreq(ly,d=dy/(2*cp.pi)) # ky list\n",
    "    [kxm, kym]=cp.meshgrid(kxl, kyl,indexing='ij') # kx, ky matrices\n",
    "    k2m = kxm**2 + kym**2 # k^2 matrix\n",
    "    k4m = k2m**2 # k^4 matrix\n",
    "    return(kxm, kym, k2m, k4m)\n",
    "\n",
    "lx = 256        # length on x\n",
    "ly = 256        # length on y\n",
    "dx = dy = 1.0   # unit length\n",
    "c0 = 0.4        # initial composition average\n",
    "fluc = 0.05     # initial composition deviation\n",
    "A = 1.0         # factor A\n",
    "M = 1.0         # diffustion M\n",
    "dt = 0.05       # time step\n",
    "kappa = 0.5     # interface kappa\n",
    "tsteps = 5000   # simulation total steps\n",
    "dsteps = 250    # dump data every dsteps\n",
    "nsteps = 200    # nucleation steps (not used in this code)\n",
    "\n",
    "c = cp.random.normal(c0, fluc, (lx, ly))    # initialize\n",
    "(kx, ky, k2, k4) = ksComp(lx, ly, dx, dy)   # prepare k's\n",
    "fname = 'spinodal'\n",
    "\n",
    "for t in range(tsteps):\n",
    "    fnl = 4*A*c**3 - 6*A*c**2   # f_nl\n",
    "    ck = cp.fft.rfft2(c)          # c(k)\n",
    "    fnlk = cp.fft.rfft2(fnl)      # f_nl(k)\n",
    "    nom = ck - dt*M*k2*fnlk              # nominator\n",
    "    denom = 1 + dt*M*k2*(2*A+kappa*k2)   # denominator\n",
    "    ck = nom/denom              # iteration\n",
    "    c = cp.fft.irfft2(ck)         # c\n",
    "    if (np.mod(t, dsteps) == 0):\n",
    "        c_3d = cp.asnumpy(c[cp.newaxis, :, :])\n",
    "        gridToVTK(fname+'.'+str(t), x=np.arange(ly)*dy, y=np.arange(lx)*dx, z=np.array([0.0]), pointData = {'composition': c_3d})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import cupy as cp\n",
    "from pyevtk.hl import gridToVTK\n",
    "\n",
    "def ksComp(lx,ly,lz,dx,dy,dz):\n",
    "    \"\"\" Compute the k-space elements\n",
    "\n",
    "    Args:\n",
    "        lx (int): number of elements along x\n",
    "        ly (int): number of elements along y\n",
    "        lz (int): number of elements along z\n",
    "        dx (float): length step along x\n",
    "        dy (float): length step along y\n",
    "        dz (float): length step along z\n",
    "    \"\"\"\n",
    "    kxl = cp.fft.fftfreq(lx,d=dx/(2*np.pi)) # kx list\n",
    "    kyl = cp.fft.fftfreq(ly,d=dy/(2*np.pi)) # ky list\n",
    "    kzl = cp.fft.rfftfreq(lz,d=dz/(2*np.pi)) # kz list\n",
    "    [kxm, kym, kzm]=cp.meshgrid(kxl, kyl, kzl, indexing='ij') # kx, ky, kz matrices\n",
    "    k2m = kxm**2 + kym**2 + kzm**2  # k^2 matrix\n",
    "    k4m = k2m**2   # k^4 matrix\n",
    "    return(kxm, kym, kzm, k2m, k4m)\n",
    "\n",
    "lx = 64         # length on x\n",
    "ly = 96         # length on y\n",
    "lz = 128        # length of z\n",
    "dx = dy = dz = 1.0   # unit length\n",
    "c0 = 0.4        # initial composition average\n",
    "fluc = 0.05     # initial composition deviation\n",
    "A = 1.0         # factor A\n",
    "M = 1.0         # diffustion M\n",
    "dt = 0.05       # time step\n",
    "kappa = 0.5     # interface kappa\n",
    "tsteps = 5000   # simulation total steps\n",
    "dsteps = 250    # dump data every dsteps\n",
    "nsteps = 200    # nucleation steps (not used in this code)\n",
    "\n",
    "c = cp.random.normal(c0, fluc, (lx, ly, lz))    # initialize\n",
    "(kx, ky, kz, k2, k4) = ksComp(lx, ly, lz, dx, dy, dz)   # prepare k's\n",
    "fname = 'spinodal3D'\n",
    "\n",
    "for t in range(tsteps):\n",
    "    fnl = 4*A*c**3 - 6*A*c**2   # f_nl\n",
    "    ck = cp.fft.rfftn(c)          # c(k)\n",
    "    fnlk = cp.fft.rfftn(fnl)      # f_nl(k)\n",
    "    nom = ck - dt*M*k2*fnlk              # nominator\n",
    "    denom = 1 + dt*M*k2*(2*A+kappa*k2)   # denominator\n",
    "    ck = nom/denom              # iteration\n",
    "    c = cp.fft.irfftn(ck)         # c\n",
    "    if (np.mod(t, dsteps) == 0):\n",
    "        gridToVTK(fname+'.'+str(t), x=np.arange(lz)*dz, y=np.arange(ly)*dy, z=np.arange(lx)*dx, pointData = {'composition': cp.asnumpy(c)})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the 2D case, it is GPU=$1.8s$ compared to CPU=$6.6s$ that $3.66\\times$  faster; for the 3D case, it is GPU=$21.1s$ compare to CPU=$121.1s$ that $5.73\\times$ faster. To prepare an animation\n",
    "```\n",
    "convert -delay 20 -loop 0 animation.*.png animation.gif\n",
    "```\n",
    "<img src=\"./animation.gif\" width=\"600\" alt=\"p1\">\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "microTi",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
